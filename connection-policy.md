### 구현할 기능에 따라 통신 규약 작성
***

- 지역, 위치, 존, 구역, 주차장, 좌표 의미가 너무 다양하고 모호하다. 이것을 정해야 데이터베이스안에 데이터 Key, Field 컬럼들을 규격화 할것이다.


***

### Collections

|컬렉션명|컬렉션 설명|
|:---:|:---|
|users|로그인 사용자 정보|
|points|추천한 주차 가능/불가능 좌표 정보|
|parks|주차존 정보|
|evals|주차존에 대한 사용자 평점 정보|
|reviews|주차존에 대한 사용자 리뷰 정보|

### Documents

|컬렉션명|docu 한글명|docu 영명|docu 타입|비고|
|:---:|:---:|:---:|:---:|:---|
|users|사용자_식별코드|_id|ObjectId|자동생성|
||사용자_아이디|user_id|String||
||사용자_비밀번호|user_pwd|String||
||사용자_이름|user_name|String||
||사용자_별명|user_nick|String||
|points|좌표_식별코드|_id|ObjectId|자동생성|

|parks|||||

|evals|||||

|reviews|||||



|기본값|왼쪽 정렬|가운데 정렬|오른쪽 정렬|
|---|:---|:---:|---:|
|내용 1|내용 2|내용 3|내용 4|
|내용 5|내용 6|내용 7|내용 8|
|내용 9|내용 10|내용 11|내용 12|




***

- create : 데이터 생성
- read : 데이터 읽기
- update : 데이터 수정
- delete : 데이터 제거

***

## connection : APIserver & DBserver 

1. 유저가 추천한 주차 가능 위치 create
   - 요청 : 원-> (주차가능코드, 중심의 위도, 중심의 경도, 반지름) / 사각형 -> (주차가능코드, 기준의 위도, 기준의 경도, 가로, 세로)
   - 응답 : "create 성공!" 관련 정보 -> 응답상태코드 활용

2. 유저가 추천한 주차 불가능 위치 create
   - 요청 : 원-> (주차불가능코드, 중심의 위도, 중심의 경도, 반지름) / 사각형 -> (주차불가능코드, 기준의 위도, 기준의 경도, 가로, 세로)
   - 응답 : "create 성공!" 관련 정보 -> 응답상태코드 활용

3. 클러스터링 된( = 업데이트 된) 주자존 read
   - ex) 시립대 주차존을 달라.
   - _프로트타입에서는 시립대에만 국한되어 고려하나, 본 프로젝트에서는 부산대, 건대, 시립대처럼 지역으로 나눠야 하지 않을까? 그래야지 데이터를 보관할 때, **시**에 따라 부산(부산대), 서울(건대, 시립대) / **구**에 따라 동대문구(시립대), 광진구(건대) 와 같이 정렬될 것이다. 그러면 지난번 회의에서 언급한 비방동기/ 동기식을 적용할 수 있을것이다. 허나 이것은 급하지 않음._
   - 요청 : 해당 자체 document 테이블 read (시립대 주차존) 
   - 응답 : (해당 지역)시립대 -> (주차존의 수) -> 해당 주차존 (꼭짓점의 수, 위도[1,...,n], 경도[1,...,n])
  
_원형 추천같은 경우 클러스터링을 어떻게 하느냐에 따라 결과 주차존이 달라질 것이다. 추천과 동일하게 포인트와 원형으로 주차존 출력 가능하다._
_혹은 클러스터링을 통해 불규칙적인 형태로 구현할 수 있다. 그렇게 된다면 point 가 무수히 많아질 것이다._

## connection : SYSTEMserver & DBserver 

1. 유저 회원가입을 위한 유저 create
   - 요청 : (사용자아이디, 사용자비밀번호, 사용자이름, 사용자별명) 
   - 응답 : "create 성공!" 관련 정보 -> 응답상태코드 활용

2. 유저 로그인을 위한 read
   - _로그인을 위해서 user 정보가 일치함을 DBserver에서 처리하는지, 아니면 **SYSTEMserver에서 처리하는지**_
   - 요청 : (사용자아이디)
   - 응답 : (사용자아이디, 사용자비밀번호, 사용자이름, 사용자별명)

3. 해당 주차존에 대한 평점 작성(create)
   - 요청 : (사용자아이디, 평점, 평점시각)
   - 응답 : "create 성공!" 관련 정보 -> 응답상태코드 활용
  
4. 해당 주차존에 대한 평점 보기(read)
   - 요청 : (주차존식별코드)
   - 응답 : (평점)
   - _평점 평균 계산은 DBserver에서 처리하는지, 아니면 SYSTEMserver에서 처리하는지... 정할 필요가 있다. DBserver에서 평균을 계산하고 평점을 계산하여 데이터를 넣는 방법과 SYSTEMserver에서 평균을 계산하고 그 값을 데베에 저장하는 방법. 어떤게 컴에게 부담되지 않을까??_
  
5. 해당 주차존에 대한 리뷰 작성(create)
   - 요청 : (사용자아이디, 리뷰, 리뷰시각)
   - 응답 : "create 성공!" 관련 정보 -> 응답상태코드 활용
  
6. 해당 주차존에 대한 리뷰 보기(read)
   - 요청 : (주차존식별코드)
   - 응답 : (리뷰, 리뷰시각)
  
7. 해당 주차존에 대한 리뷰 수정(update)
   - 요청 : (주차존식별코드, 사용자아이디, 리뷰, 리뷰시각)
   - 응답 : "update 성공!" 관련 정보 -> 응답상태코드 활용 / 혹은 수정된 (사용자아이디, 리뷰, 리뷰시각) 제공
  
8. 해당 주차존에 대한 리뷰 제거(delete)
   - 요청 : (주차존식별코드, 사용자아이디)
   - 응답 : "delete 성공!" 관련 정보 -> 응답상태코드 활용

- _주차존 클러스터링을 SYSTEM에서 다룬다면, 여기로도 주차 관련 데이터 통신이 필요하겠네요._

9. 추천받은 주차 가능 위치 read
   - 요청 : 해당 자체 document 테이블 read (시립대)
   - 응답 : 원-> (주차가능코드, 중심의 위도, 중심의 경도, 반지름) / 사각형 -> (주차가능코드, 기준의 위도, 기준의 경도, 가로, 세로)

10. 추천받은 주차 불가능 위치 read
   - 요청 : 해당 자체 document 테이블 read (시립대)
   - 응답 : 원-> (주차불가능코드, 중심의 위도, 중심의 경도, 반지름) / 사각형 -> (주차불가능코드, 기준의 위도, 기준의 경도, 가로, 세로)
  
11. 클러스터링 된 주차존 create
    - _이전 주차존을 delete 후 새로운 주차존을 create 하나요? 기존 주차존에 update 하나요? 아니면.. 둘다 병합..??_
    - 요청 : (꼭짓점의 수, 위도[1,...,n], 경도[1,...,n])
    - 응답 : "create 성공!" 관련 정보 -> 응답상태코드 활용 / (주차존의 수) 제공

***

## 파라미터 값 설정

> 원 -> (주차가능코드, 중심의 위도, 중심의 경도, 반지름)    
> (point_state, point_latitude, point_longititude, point_radius)

> (꼭짓점의 수, 위도1, 경도1, ..., 위도n, 경도n)   
> (point_count, park_latitude[], park_longititude[]) 

> (사용자아이디, 사용자비밀번호, 사용자이름, 사용자별명)    
> (user_id, user_pwd, user_name, user_nick)

> (주차존식별코드)   
> (zone_no)

> (사용자아이디, 평점, 평점시각)   
> (user_id, view_stars, view_stars_date)

> (주차존식별코드, 사용자아이디, 리뷰, 리뷰시각)   
> (zone_id, user_id, view_review, view_review_date)

***

 _아직 TCP, UDP 개념이 명확하지 않아서 사용해야할 URL은 추후에 알려드리겠어요.. 일단 parameter 값만 확인 부탁드립니다._